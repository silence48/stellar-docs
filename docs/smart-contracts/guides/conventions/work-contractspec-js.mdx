---
title: Work with ContractSpecs in JavaScript
hide_table_of_contents: true
draft: true
---

### Guide: Work with ContractSpecs in JavaScript

#### Introduction

Soroban smart contracts, integral to the Stellar network, utilize detailed contract specifications to define their behavior and interactions. A contract specification outlines the functions, parameters, and events within a smart contract, guiding developers in how to interact with these contracts through JavaScript. This guide will walk you through the process of creating a contract client and invoking smart contracts using JavaScript.

#### Prerequisites

To follow this guide, you will need:

- Node.js (version 18 or later)
- `@stellar/stellar-sdk` package
- A working knowledge of JavaScript and basic understanding of smart contracts

### Information on the Contract Spec

The `ContractSpec` class from the Stellar SDK provides a powerful way to handle and interact with the interface of a Rust smart contract. Here are some of the key functionalities:

1. **Convert Native Values to ScVals**: The `funcArgsToScVals` method converts native JavaScript arguments to `ScVal` objects required for calling the contract functions.

   ```typescript
   const args = {
     arg1: "value1",
     arg2: 1234,
   };
   const scArgs = contractSpec.funcArgsToScVals("funcName", args);
   ```

2. **Convert ScVals to Native Values**: The `funcResToNative` method converts the result `ScVal` from a function call to a native JavaScript value.

   ```typescript
   const resultScv = "AAA=="; // Base64 encoded ScVal
   const result = contractSpec.funcResToNative("funcName", resultScv);
   ```

3. **Get Function Specifications**: You can retrieve the function specifications defined in the contract.

   ```typescript
   const functions = contractSpec.funcs();
   const funcSpec = contractSpec.getFunc("funcName");
   ```

4. **Handle Error Cases**: The `errorCases` method retrieves the error cases defined in the contract, which can be used to handle different error scenarios.

   ```typescript
   const errors = contractSpec.errorCases();
   ```

5. **Convert to JSON Schema**: The `jsonSchema` method converts the contract specification to a JSON schema, which can be useful for documentation or generating client code.

   ```typescript
   const schema = contractSpec.jsonSchema();
   const funcSchema = contractSpec.jsonSchema("funcName");
   ```

By leveraging these methods, you can easily convert between native JavaScript values and the `ScVal` format required for interacting with Soroban smart contracts, handle errors effectively, and generate useful documentation or client code based on the contract specification.

#### Step-by-Step Guide

##### Example Contract: TokenManager

Here's an example Rust contract that we'll be working with. This contract, `TokenManager`, manages token balances and includes functions to initialize, deposit, withdraw, and check balances. It also includes custom errors for different failure scenarios.

```rust
use soroban_sdk::{contract, contractimpl, Address, Env, Symbol, contracterror};

#[contract]
pub struct TokenManager;

#[contracterror]
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum TokenManagerError {
    InternalError = 1,
    UnauthorizedError = 2,
    InsufficientBalanceError = 3,
    OverflowError = 4,
}

#[contractimpl]
impl TokenManager {
    pub fn initialize(e: Env, admin: Address) {
        e.storage().set(&Symbol::short("admin"), &admin);
    }

    pub fn deposit(e: Env, user: Address, amount: i128) -> Result<(), TokenManagerError> {
        let key = Symbol::short("balance").join(&user);
        let mut balance: i128 = e.storage().get(&key).unwrap_or(0);
        balance = balance.checked_add(amount).ok_or(TokenManagerError::OverflowError)?;
        e.storage().set(&key, &balance);
        Ok(())
    }

    pub fn withdraw(e: Env, user: Address, amount: i128) -> Result<(), TokenManagerError> {
        let key = Symbol::short("balance").join(&user);
        let mut balance: i128 = e.storage().get(&key).unwrap_or(0);
        if balance < amount {
            return Err(TokenManagerError::InsufficientBalanceError);
        }
        balance -= amount;
        e.storage().set(&key, &balance);
        Ok(())
    }

    pub fn get_balance(e: Env, user: Address) -> i128 {
        let key = Symbol::short("balance").join(&user);
        e.storage().get(&key).unwrap_or(0)
    }
}
```

##### Step 1: Deploy the Contract

First, deploy your Soroban smart contract to the network.

```bash
soroban contract deploy --source orbit --network testnet --wasm token_manager.wasm
```

This command will return the contract ID, for example: `CBEUVPRZKMCX5MPUAF2JMKMRIFEXXJXQXBLUUW6LMN5GDDQQSX3UHYXA`.

##### Step 2: Generate TypeScript Bindings

Use the Soroban CLI to generate TypeScript bindings which use the contract's schema specifications to provide type-checked contract methods.

```bash
soroban contract bindings typescript --output-dir testbindings --network testnet --contract-id CBEUVPRZKMCX5MPUAF2JMKMRIFEXXJXQXBLUUW6LMN5GDDQQSX3UHYXA
```

This command will create TypeScript bindings in the specified directory.

Alternatively, you can get your spec using javascript: credit to [@mason in Stellar Developers discord](https://discord.com/channels/897514728459468821/966788672164855829/1201708320336138271) and [his gist here] (https://gist.github.com/masonforest/27ebfafa3452227937b842c56731d817)

Save this file as `readContractSpec.js`

```typescript
import fs from "node:fs/promises";
import { ContractSpec, xdr } from "@stellar/stellar-sdk";
import jsXdr from "@stellar/js-xdr";

const { XdrReader } = jsXdr;

async function readContractSpec(path) {
  const wasmBuffer = await fs.readFile(path);
  const wasmModule = await WebAssembly.compile(wasmBuffer);
  const reader = new XdrReader(
    Buffer.from(
      WebAssembly.Module.customSections(wasmModule, "contractspecv0")[0],
    ),
  );
  const specs = [];

  do {
    specs.push(xdr.ScSpecEntry.read(reader));
  } while (!reader.eof);

  return new ContractSpec(specs);
}

async function main() {
  const wasmFilePath = process.argv[2];

  if (!wasmFilePath) {
    console.error("Usage: node readContractSpec.js <wasmFilePath>");
    process.exit(1);
  }

  try {
    const contractSpec = await readContractSpec(wasmFilePath);
    console.log("Contract Specification:", contractSpec);
  } catch (error) {
    console.error("Error reading contract specification:", error);
  }
}

main();
```

### Running the Script

To run the script with `mycontract.wasm`, use the following command in your terminal:

```bash
node readContractSpec.js mycontract.wasm
```

This will execute the `readContractSpec` function with the `mycontract.wasm` file provided as a command-line argument and output the contract specification to the console. Copy the output for the next step

##### Step 3: Extract the Contract Spec

Inside the generated bindings directory (`testbindings/src/index.ts`)(if you used the generated bindings), you'll find the contract specification. Look for a line that initializes a new `ContractSpec` object, such as: If you used the easy javascript then just use the output from that!

```typescript
new ContractSpec(["thespecishere"]);
```

Copy the spec from there and use it in your JavaScript class.

##### Step 4: Create the Contract Client Class

Create a new file called `TokenManagerContract.ts` and define the contract client class using the extracted contract specification.

```typescript
// TokenManagerContract.ts
import { Address, Contract } from "@stellar/stellar-sdk";
import { Spec as ContractSpec, i128 } from "@stellar/stellar-sdk/contract";

// Copy the contract spec from the generated TypeScript bindings
const contractSpec = new ContractSpec([
  "AAAAAAAAAAAAAAAKaW5pdGlhbGl6ZQAAAAAABAAAAAAAAAAFYWRtaW4AAAAAAAATAAAAAAAAAAJkZXBvc2l0AAAAAAATAAAAAAAAAAl1c2VyAAAAEwAAAAAAAAAGYW1vdW50AAAAAAATAAAAAAAAAAR3aXRoZHJhdwAAAAAABgAAAAAAAAAFcmVzdWx0AAAAAAA=",
  "AAAAAAAAAAAAAAANZ2V0X2JhbGFuY2UAAAAAAAIAAAAAAAAAAl9yZXN1bHQAAAAAEwAAAAAAAAAJdXNlcl9hZGRyAAAAAAAT",
  "AAAAAAAAAAAAAAAAAUNvbnRyYWN0RXJyb3JNYW5hZ2VyAAAACwAAAAAAAAAAAAALAA==",
]);

export class TokenManagerContract extends Contract {
  static spec = contractSpec;

  constructor(address: string) {
    super(address);
  }

  public initialize(admin: Address) {
    const invokeArgs = TokenManagerContract.spec.funcArgsToScVals(
      "initialize",
      {
        admin,
      },
    );
    const operation = this.call("initialize", ...invokeArgs);
    return operation.toXDR("base64");
  }

  public deposit(user: Address, amount: i128) {
    const invokeArgs = TokenManagerContract.spec.funcArgsToScVals("deposit", {
      user,
      amount,
    });
    const operation = this.call("deposit", ...invokeArgs);
    return operation.toXDR("base64");
  }

  public withdraw(user: Address, amount: i128) {
    const invokeArgs = TokenManagerContract.spec.funcArgsToScVals("withdraw", {
      user,
      amount,
    });
    const operation = this.call("withdraw", ...invokeArgs);
    return operation.toXDR("base64");
  }

  public get_balance(user: Address) {
    const invokeArgs = TokenManagerContract.spec.funcArgsToScVals(
      "get_balance",
      {
        user,
      },
    );
    const operation = this.call("get_balance", ...invokeArgs);
    return operation.toXDR("base64");
  }

  static readonly parsers = {
    initialize: (result: string) =>
      TokenManagerContract.spec.funcResToNative("initialize", result),
    deposit: (result: string) =>
      TokenManagerContract.spec.funcResToNative("deposit", result),
    withdraw: (result: string) =>
      TokenManagerContract.spec.funcResToNative("withdraw", result),
    get_balance: (result: string) =>
      TokenManagerContract.spec.funcResToNative("get_balance", result),
  };
}

export const Errors = {
  1: { message: "Internal error" },
  2: { message: "Unauthorized error" },
  3: { message: "Insufficient balance" },
  4: { message: "Overflow error" },
};
```

##### Step 5: Invoke the Contract

To invoke a smart contract function, create an instance of the contract client and call the desired function with the appropriate arguments.

```typescript
import { Address } from "@stellar/stellar-sdk";
import { TokenManagerContract } from "./TokenManagerContract";
import { invokeSorobanOperation, TxParams } from "./invokeSorobanOperation"; // Assuming you have these utility functions

// Create an instance of the contract client
const contractAddress =
  "CBEUVPRZKMCX5MPUAF2JMKMRIFEXXJXQXBLUUW6LMN5GDDQQSX3UHYXA";
const tokenManager = new TokenManagerContract(contractAddress);

// Define transaction parameters
const txParams: TxParams = {
  account: await config.rpc.getAccount(config.admin.publicKey()),
  txBuilderOptions: {
    fee: "10000",
    timebounds: {
      minTime: 0,
      maxTime: 0,
    },
    networkPassphrase: config.passphrase,
  },
  signerFunction: async (txXdr: string) => {
    return signWithKeypair(txXdr, config.passphrase, config.admin);
  },
};

// Invoke the initialize function
const adminAddress = Address.fromString(
  "GB4UG5H5MCYPIH7GM7CBZBLOOIE2K7HMDMPK4TPZ5UEIZ2HOI5RL535V",
);

const txXDR = tokenManager.initialize(adminAddress);
console.log("Transaction XDR:", txXDR);

// Example invocation
const result = await invokeSorobanOperation(
  txXDR,
  TokenManagerContract.parsers.initialize,
  txParams,
);
console.log("Result:", result);
```

### Full TokenManagerContract.ts File

```typescript
// TokenManagerContract.ts
import { Address, Horizon, Contract } from '@stellar/stellar-sdk';
import { Spec as ContractSpec, i128 } from '@stellar/stellar-sdk/contract';

/**
 * Interface representing a network configuration.
 */
export interface Network {
  rpc: string;
  passphrase: string;
  maxConcurrentRequests?: number;
  opts?: Horizon.Server.Options;
}

/**
 * Object containing network configurations.
 */
export const networks = {
  testnet: {
    networkPassphrase: "Test SDF Network ; September 2015",
    contractId: "CBEUVPRZKMCX5MPUAF2JMKMRIFEXXJXQXBLUUW6LMN5GDDQQSX3UHYXA",
  }
};

/**
 * Object containing error messages for various error codes.
 */
export const Errors = {
  1: { message: "Internal error" },
  2: { message: "Unauthorized error" },
  3: { message: "Insufficient balance" },
  4: { message: "Overflow error" },
};

/**
 * Class representing the TokenManager contract.
 */
export class TokenManagerContract extends Contract {
  static spec: ContractSpec = new ContractSpec([
    "AAAAAAAAAAAAAAAKaW5pdGlhbGl6ZQAAAAAABAAAAAAAAAAFYWRtaW4AAAAAAAATAAAAAAAAAAJkZXBvc2l0AAAAAAATAAAAAAAAAAl1c2VyAAAAEwAAAAAAAAAGYW1vdW50AAAAAAATAAAAAAAAAAR3aXRoZHJhdwAAAAAABgAAAAAAAAAFcmVzdWx0AAAAAAA=",
    "AAAAAAAAAAAAAAANZ2V0X2JhbGFuY2UAAAAAAAIAAAAAAAAAAl9yZXN1bHQAAAAAEwAAAAAAAAAJdXNlcl9hZGRyAAAAAAAT",
    "AAAAAAAAAAAAAAAAAUNvbnRyYWN0RXJyb3JNYW5hZ2VyAAAACwAAAAAAAAAAAAALAA==",
  ]);

  static readonly parsers = {
    initialize: (result: string) => TokenManagerContract.spec.funcResToNative('initialize', result),
    deposit: (result: string) => TokenManagerContract.spec.funcResToNative('deposit', result),
    withdraw: (result: string) => TokenManagerContract.spec.funcResToNative('withdraw', result),
    get_balance: (result: string) => TokenManagerContract.spec.funcResToNative('get_balance', result),
  };

  constructor(address: string) {
    super(address);
  }

  public initialize(admin: Address) {
    const invokeArgs = TokenManagerContract.spec.funcArgsToScVals('initialize', {
      admin,
    });
    const operation = this.call('initialize', ...invokeArgs);
    return operation.toXDR('base64');
  }

  public deposit(user: Address, amount: i128) {
    const invokeArgs = TokenManagerContract.spec.funcArgsToScVals('deposit', {
      user,
      amount,
    });
    const operation = this.call('deposit', ...invokeArgs);
    return operation.toXDR('base64');
  }

  public withdraw(user: Address, amount: i128) {
    const invokeArgs = TokenManagerContract.spec.funcArgsToScVals('withdraw', {
      user,
      amount,
    });
    const operation = this.call('withdraw', ...invokeArgs);
    return operation.toXDR('base64');
  }

  public get_balance(user: Address) {
    const invokeArgs = TokenManagerContract.spec.funcArgsToScVals('get_balance', {
      user,
    });
    const operation = this.call('get_balance', ...invokeArgs);
    return operation.toXDR('base64');
  }
}
```

### Helper Function: invokeSorobanOperation

```typescript
import {
  SorobanRpc,
  TransactionBuilder,
  TimeoutInfinite,
  xdr,
  Transaction,
} from "@stellar/stellar-sdk";

export async function invokeSorobanOperation<T>(
  operation: string,
  parser: (result: string) => T,
  txParams: TxParams,
  sorobanData?: xdr.SorobanTransactionData,
): Promise<T | undefined> {
  console.log("invoking soroban operation");
  const account = await config.rpc.getAccount(txParams.account.accountId());
  console.log("the account is", account);
  const txBuilder = new TransactionBuilder(account, txParams.txBuilderOptions)
    .addOperation(xdr.Operation.fromXDR(operation, "base64"))
    .setTimeout(TimeoutInfinite);

  if (sorobanData) {
    txBuilder.setSorobanData(sorobanData);
  }

  const transaction = txBuilder.build();
  console.log("Transaction built with sequence number:", transaction.sequence);

  const simulation = await config.rpc.simulateTransaction(transaction);

  if (SorobanRpc.Api.isSimulationError(simulation)) {
    console.log("Simulation error with details:", simulation);
    throw new Error(simulation.error);
  }

  const assembledTx = SorobanRpc.assembleTransaction(
    transaction,
    simulation,
  ).build();

  const signedTx = new Transaction(
    await txParams.signerFunction(assembledTx.toXDR()),
    config.passphrase,
  );

  try {
    const response = await sendTransaction(signedTx, parser);
    return response;
  } catch (error) {
    console.error("Transaction submission failed with error:", error);
    throw error;
  }
}
```

### Example TxParams

```typescript
const txParams: TxParams = {
  account: await config.rpc.getAccount(config.admin.publicKey()),
  txBuilderOptions: {
    fee: "10000",
    timebounds: {
      minTime: 0,
      maxTime: 0,
    },
    networkPassphrase: config.passphrase,
  },
  signerFunction: async (txXdr: string) => {
    return signWithKeypair(txXdr, config.passphrase, config.admin);
  },
};
```

### Example Invocation

```typescript
import { Address } from "@stellar/stellar-sdk";
import { TokenManagerContract } from "./TokenManagerContract";
import { invokeSorobanOperation, TxParams } from "./invokeSorobanOperation"; // Assuming you have these utility functions

// Create an instance of the contract client
const contractAddress =
  "CBEUVPRZKMCX5MPUAF2JMKMRIFEXXJXQXBLUUW6LMN5GDDQQSX3UHYXA";
const tokenManager = new TokenManagerContract(contractAddress);

// Define transaction parameters
const txParams: TxParams = {
  account: await config.rpc.getAccount(config.admin.publicKey()),
  txBuilderOptions: {
    fee: "10000",
    timebounds: {
      minTime: 0,
      maxTime: 0,
    },
    networkPassphrase: config.passphrase,
  },
  signerFunction: async (txXdr: string) => {
    return signWithKeypair(txXdr, config.passphrase, config.admin);
  },
};

// Invoke the initialize function
const adminAddress = Address.fromString(
  "GB4UG5H5MCYPIH7GM7CBZBLOOIE2K7HMDMPK4TPZ5UEIZ2HOI5RL535V",
);

const txXDR = tokenManager.initialize(adminAddress);
console.log("Transaction XDR:", txXDR);

// Example invocation
const result = await invokeSorobanOperation(
  txXDR,
  TokenManagerContract.parsers.initialize,
  txParams,
);
console.log("Result:", result);
```

### Conclusion

By following these steps, you can create a contract client and interact with Soroban smart contracts using JavaScript. This guide covered the basics of obtaining the contract specification, creating a contract client, and invoking contract functions.
