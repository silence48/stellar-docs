---
title: Work with ContractSpecs in JavaScript
hide_table_of_contents: true
draft: true
---

### Guide: Work with ContractSpecs in JavaScript

#### Introduction

Soroban smart contracts, integral to the Stellar network, utilize detailed contract specifications to define their behavior and interactions. A contract specification outlines the functions, parameters, and events within a smart contract, guiding developers in how to interact with these contracts through JavaScript. This guide will walk you through the process of creating a contract client and invoking smart contracts using JavaScript.

#### Prerequisites

To follow this guide, you will need:

- Node.js (version 18 or later)
- `@stellar/stellar-sdk` package
- A working knowledge of JavaScript and basic understanding of smart contracts

### Information on the Contract Spec

The `Spec` class from the Stellar SDK provides a powerful way to handle and interact with the smart contract specifications. Here are some of the key functionalities:

1. **Convert Native Values to ScVals**: The `funcArgsToScVals` method converts native JavaScript arguments to `ScVal` objects required for calling the contract functions.

   ```typescript
   const args = {
     arg1: "value1",
     arg2: 1234,
   };
   const scArgs = contractSpec.funcArgsToScVals("funcName", args);
   ```

2. **Convert ScVals to Native Values**: The `funcResToNative` method converts the result `ScVal` from a function call to a native JavaScript value.

   ```typescript
   const resultScv = "AAA=="; // Base64 encoded ScVal
   const result = contractSpec.funcResToNative("funcName", resultScv);
   ```

3. **Get Function Specifications**: You can retrieve the function specifications defined in the contract.

   ```typescript
   const functions = contractSpec.funcs();
   const funcSpec = contractSpec.getFunc("funcName");
   ```

4. **Handle Error Cases**: The `errorCases` method retrieves the error cases defined in the contract, which can be used to handle different error scenarios.

   ```typescript
   const errors = contractSpec.errorCases();
   ```

5. **Convert to JSON Schema**: The `jsonSchema` method converts the contract specification to a JSON schema, which can be useful for documentation or generating client code.

   ```typescript
   const schema = contractSpec.jsonSchema();
   const funcSchema = contractSpec.jsonSchema("funcName");
   ```

By leveraging these methods, you can easily convert between native JavaScript values and the `ScVal` format required for interacting with Soroban smart contracts, handle errors effectively, and generate useful documentation or client code based on the contract specification.

#### Step-by-Step Guide

##### Example Contract: TokenManager

Here's an example Rust contract that we'll be working with. This contract, `TokenManager`, manages token balances and includes functions to initialize, deposit, withdraw, and check balances. It also includes custom errors for different failure scenarios.

```rust
use soroban_sdk::{contract, contractimpl, Address, Env, Symbol, contracterror};

#[contract]
pub struct TokenManager;

#[contracterror]
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum TokenManagerError {
    InternalError = 1,
    UnauthorizedError = 2,
    InsufficientBalanceError = 3,
    OverflowError = 4,
}

#[contractimpl]
impl TokenManager {
    pub fn initialize(e: Env, admin: Address) {
        e.storage().set(&Symbol::short("admin"), &admin);
    }

    pub fn deposit(e: Env, user: Address, amount: i128) -> Result<(), TokenManagerError> {
        let key = Symbol::short("balance").join(&user);
        let mut balance: i128 = e.storage().get(&key).unwrap_or(0);
        balance = balance.checked_add(amount).ok_or(TokenManagerError::OverflowError)?;
        e.storage().set(&key, &balance);
        Ok(())
    }

    pub fn withdraw(e: Env, user: Address, amount: i128) -> Result<(), TokenManagerError> {
        let key = Symbol::short("balance").join(&user);
        let mut balance: i128 = e.storage().get(&key).unwrap_or(0);
        if balance < amount {
            return Err(TokenManagerError::InsufficientBalanceError);
        }
        balance -= amount;
        e.storage().set(&key, &balance);
        Ok(())
    }

    pub fn get_balance(e: Env, user: Address) -> i128 {
        let key = Symbol::short("balance").join(&user);
        e.storage().get(&key).unwrap_or(0)
    }
}
```

There are a few options to get your contract Spec object to work with in javascript. The Spec is constructed from a (xdr.ScSpecEntry)[https://github.com/stellar/js-stellar-base/blob/5efdff0b2a78ed842f7463340b4ff23eb4370635/xdr/curr/Stellar-contract-spec.x#L228]

#### Option 1: Create Contract Specification in JavaScript

To create a contract specification from scratch in JavaScript, we need to define the functions and errors of the contract. Here's how you can do it:

```typescript
import { xdr } from "@stellar/stellar-base";
import { Spec } from "@stellar/stellar-sdk";

// Define the contract specification entries
const contractSpecEntries = [
  // Define the initialize function
  xdr.ScSpecEntry.scSpecEntryFunctionV0(
    new xdr.ScSpecFunctionV0({
      name: "initialize",
      doc: "Initialize the contract with an admin address.",
      inputs: [
        new xdr.ScSpecFunctionInputV0({
          name: "admin",
          doc: "Admins Public Key",
          type: xdr.ScSpecTypeDef.scSpecTypeAddress(),
        }),
      ],
      outputs: [],
    }),
  ),

  // Define the deposit function
  xdr.ScSpecEntry.scSpecEntryFunctionV0(
    new xdr.ScSpecFunctionV0({
      name: "deposit",
      doc: "Deposits an amount into the user's balance.",
      inputs: [
        new xdr.ScSpecFunctionInputV0({
          name: "user",
          doc: "User's Public Key",
          type: xdr.ScSpecTypeDef.scSpecTypeAddress(),
        }),
        new xdr.ScSpecFunctionInputV0({
          name: "amount",
          doc: "Amount to deposit",
          type: xdr.ScSpecTypeDef.scSpecTypeI128(),
        }),
      ],
      outputs: [xdr.ScSpecTypeDef.scSpecTypeVoid()],
    }),
  ),

  // Define the withdraw function
  xdr.ScSpecEntry.scSpecEntryFunctionV0(
    new xdr.ScSpecFunctionV0({
      name: "withdraw",
      doc: "Withdraws an amount from the user's balance.",
      inputs: [
        new xdr.ScSpecFunctionInputV0({
          name: "user",
          doc: "User's Public Key",
          type: xdr.ScSpecTypeDef.scSpecTypeAddress(),
        }),
        new xdr.ScSpecFunctionInputV0({
          name: "amount",
          doc: "Amount to withdraw",
          type: xdr.ScSpecTypeDef.scSpecTypeI128(),
        }),
      ],
      outputs: [xdr.ScSpecTypeDef.scSpecTypeVoid()],
    }),
  ),

  // Define the get_balance function
  xdr.ScSpecEntry.scSpecEntryFunctionV0(
    new xdr.ScSpecFunctionV0({
      name: "get_balance",
      doc: "Gets the balance of the user.",
      inputs: [
        new xdr.ScSpecFunctionInputV0({
          name: "user",
          doc: "User's Public Key",
          type: xdr.ScSpecTypeDef.scSpecTypeAddress(),
        }),
      ],
      outputs: [xdr.ScSpecTypeDef.scSpecTypeI128()],
    }),
  ),

  // Define the TokenManagerError enum
  xdr.ScSpecEntry.scSpecEntryUdtErrorEnumV0(
    new xdr.ScSpecUdtErrorEnumV0({
      name: "TokenManagerError",
      doc: "Errors that can occur in the TokenManager contract.",
      lib: "token_manager",
      cases: [
        new xdr.ScSpecUdtErrorEnumCaseV0({
          name: "InternalError",
          doc: "Internal error occurred.",
          value: 1,
        }),
        new xdr.ScSpecUdtErrorEnumCaseV0({
          name: "UnauthorizedError",
          doc: "Unauthorized access.",
          value: 2,
        }),
        new xdr.ScSpecUdtErrorEnumCaseV0({
          name: "InsufficientBalanceError",
          doc: "Insufficient balance for the operation.",
          value: 3,
        }),
        new xdr.ScSpecUdtErrorEnumCaseV0({
          name: "OverflowError",
          doc: "Overflow error occurred.",
          value: 4,
        }),
      ],
    }),
  ),
];

// Initialize the contract specification
const contractSpec = new Spec(contractSpecEntries);

console.log("Contract Spec:", contractSpec);
```

**Explanation:**

- We define the contract specification entries for each function and error in the `TokenManager` contract.
- We create instances of `ScSpecFunctionV0` and `ScSpecFunctionInputV0` to define the functions and their inputs/outputs.
- We create instances of `ScSpecUdtErrorEnumV0` and `ScSpecUdtErrorEnumCaseV0` to define the custom errors.
- Finally, we initialize a `Spec` instance with the defined entries.

Now you have the complete contract specification in JavaScript. You can use this specification to interact with your Soroban smart contract.

With these steps, you have learned how to define a contract specification from scratch using JavaScript. You can proceed with deploying the contract, generating TypeScript bindings, and using the specification to interact with the contract.

#### Option 2 Get the Spec from a Deployed Contract.

##### Step 1: Deploy the Contract

First, deploy your Soroban smart contract to the network.

```bash
soroban contract deploy --source orbit --network testnet --wasm token_manager.wasm
```

This command will return the contract ID, for example: `CBEUVPRZKMCX5MPUAF2JMKMRIFEXXJXQXBLUUW6LMN5GDDQQSX3UHYXA`.

##### Step 2: Generate TypeScript Bindings

Use the Soroban CLI to generate TypeScript bindings which use the contract's schema specifications to provide type-checked contract methods.

```bash
soroban contract bindings typescript --output-dir testbindings --network testnet --contract-id CBEUVPRZKMCX5MPUAF2JMKMRIFEXXJXQXBLUUW6LMN5GDDQQSX3UHYXA
```

This command will create TypeScript bindings in the specified directory.

Alternatively, you can get your spec using javascript: credit to [@mason in Stellar Developers discord](https://discord.com/channels/897514728459468821/966788672164855829/1201708320336138271) and [his gist here] (https://gist.github.com/masonforest/27ebfafa3452227937b842c56731d817)

Save this file as `readContractSpec.js`

```typescript
import fs from "node:fs/promises";
import { Contract, xdr } from "@stellar/stellar-sdk";
import jsXdr from "@stellar/js-xdr";

const { XdrReader } = jsXdr;

async function readContractSpec(path) {
  const wasmBuffer = await fs.readFile(path);
  const wasmModule = await WebAssembly.compile(wasmBuffer);
  const reader = new XdrReader(
    Buffer.from(
      WebAssembly.Module.customSections(wasmModule, "contractspecv0")[0],
    ),
  );
  const specs = [];

  do {
    specs.push(xdr.ScSpecEntry.read(reader));
  } while (!reader.eof);

  return new Contract.Spec(specs);
}

async function main() {
  const wasmFilePath = process.argv[2];

  if (!wasmFilePath) {
    console.error("Usage: node readContractSpec.js <wasmFilePath>");
    process.exit(1);
  }

  try {
    const contractSpec = await readContractSpec(wasmFilePath);
    console.log("Contract Specification:", contractSpec);
  } catch (error) {
    console.error("Error reading contract specification:", error);
  }
}

main();
```

### Running the Script

To run the script with `mycontract.wasm`, use the following command in your terminal:

```bash
node readContractSpec.js mycontract.wasm
```

This will execute the `readContractSpec` function with the `mycontract.wasm` file provided as a command-line argument and output the contract specification to the console. Copy the output for the next step

#### Step 3: Extract the Contract Spec from Generated Bindings

Inside the generated bindings directory (`testbindings/src/index.ts`)(if you used the generated bindings), you'll find the contract specification. Look for a line that initializes a new `Spec` object, or `ContractSpec`, such as: If you used the easy javascript then just use the output from that!

```typescript
new Spec(["thespecishere"]);
```

Copy the spec from there and use it in your JavaScript class.

##### Step 4: Create the Contract Client Class

Create a new file called `TokenManagerContract.ts` and define the contract client class using the extracted contract specification.

```typescript
// TokenManagerContract.ts
import { Address, Contract } from "@stellar/stellar-sdk";
import { Spec as ContractSpec, i128 } from "@stellar/stellar-sdk/contract";
// Contract.Spec used to be ContractSpec so if you're trying to update old code to the new sdk you can just`import { Spec as ContractSpec } from "@stellar/stellar-sdk/contract"; ` as opposed to import { ContractSpec } from "@stellar/stellar-sdk";`
// Copy the contract spec from the generated TypeScript bindings
const contractSpec = new ContractSpec([
  "AAAAAAAAAAAAAAAKaW5pdGlhbGl6ZQAAAAAABAAAAAAAAAAFYWRtaW4AAAAAAAATAAAAAAAAAAJkZXBvc2l0AAAAAAATAAAAAAAAAAl1c2VyAAAAEwAAAAAAAAAGYW1vdW50AAAAAAATAAAAAAAAAAR3aXRoZHJhdwAAAAAABgAAAAAAAAAFcmVzdWx0AAAAAAA=",
  "AAAAAAAAAAAAAAANZ2V0X2JhbGFuY2UAAAAAAAIAAAAAAAAAAl9yZXN1bHQAAAAAEwAAAAAAAAAJdXNlcl9hZGRyAAAAAAAT",
  "AAAAAAAAAAAAAAAAAUNvbnRyYWN0RXJyb3JNYW5hZ2VyAAAACwAAAAAAAAAAAAALAA==",
]);

export class TokenManagerContract extends Contract {
  static spec = contractSpec;

  constructor(address: string) {
    super(address);
  }

  public initialize(admin: Address) {
    const invokeArgs = TokenManagerContract.spec.funcArgsToScVals(
      "initialize",
      {
        admin,
      },
    );
    const operation = this.call("initialize", ...invokeArgs);
    return operation.toXDR("base64");
  }

  public deposit(user: Address, amount: i128) {
    const invokeArgs = TokenManagerContract.spec.funcArgsToScVals("deposit", {
      user,
      amount,
    });
    const operation = this.call("deposit", ...invokeArgs);
    return operation.toXDR("base64");
  }

  public withdraw(user: Address, amount: i128) {
    const invokeArgs = TokenManagerContract.spec.funcArgsToScVals("withdraw", {
      user,
      amount,
    });
    const operation = this.call("withdraw", ...invokeArgs);
    return operation.toXDR("base64");
  }

  public get_balance(user: Address) {
    const invokeArgs = TokenManagerContract.spec.funcArgsToScVals(
      "get_balance",
      {
        user,
      },
    );
    const operation = this.call("get_balance", ...invokeArgs);
    return operation.toXDR("base64");
  }

  static readonly parsers = {
    initialize: (result: string) =>
      TokenManagerContract.spec.funcResToNative("initialize", result),
    deposit: (result: string) =>
      TokenManagerContract.spec.funcResToNative("deposit", result),
    withdraw: (result: string) =>
      TokenManagerContract.spec.funcResToNative("withdraw", result),
    get_balance: (result: string) =>
      TokenManagerContract.spec.funcResToNative("get_balance", result),
  };
}

export const Errors = {
  1: { message: "Internal error" },
  2: { message: "Unauthorized error" },
  3: { message: "Insufficient balance" },
  4: { message: "Overflow error" },
};
```

##### Step 5: Invoke the Contract

To invoke a smart contract function, create an instance of the contract client and call the desired function with the appropriate arguments.

```typescript
import { Address } from "@stellar/stellar-sdk";
import { TokenManagerContract } from "./TokenManagerContract";
import { invokeSorobanOperation, TxParams } from "./invokeSorobanOperation"; // Assuming you have these utility functions

// Create an instance of the contract client
const contractAddress =
  "CBEUVPRZKMCX5MPUAF2JMKMRIFEXXJXQXBLUUW6LMN5GDDQQSX3UHYXA";
const tokenManager = new TokenManagerContract(contractAddress);

// Define transaction parameters
const txParams: TxParams = {
  account: await config.rpc.getAccount(config.admin.publicKey()),
  txBuilderOptions: {
    fee: "10000",
    timebounds: {
      minTime: 0,
      maxTime: 0,
    },
    networkPassphrase: config.passphrase,
  },
  signerFunction: async (txXdr: string) => {
    return signWithKeypair(txXdr, config.passphrase, config.admin);
  },
};

// Invoke the initialize function
const adminAddress = Address.fromString(
  "GB4UG5H5MCYPIH7GM7CBZBLOOIE2K7HMDMPK4TPZ5UEIZ2HOI5RL535V",
);

const txXDR = tokenManager.initialize(adminAddress);
console.log("Transaction XDR:", txXDR);

// Example invocation
const result = await invokeSorobanOperation(
  txXDR,
  TokenManagerContract.parsers.initialize,
  txParams,
);
console.log("Result:", result);
```

### Full TokenManagerContract.ts File

```typescript
// TokenManagerContract.ts
import { Address, Horizon, Contract } from "@stellar/stellar-sdk";
import { Spec as ContractSpec, i128 } from "@stellar/stellar-sdk/contract";

/**
 * Interface representing a network configuration.
 */
export interface Network {
  rpc: string;
  passphrase: string;
  maxConcurrentRequests?: number;
  opts?: Horizon.Server.Options;
}

/**
 * Object containing network configurations.
 */
export const networks = {
  testnet: {
    networkPassphrase: "Test SDF Network ; September 2015",
    contractId: "CBEUVPRZKMCX5MPUAF2JMKMRIFEXXJXQXBLUUW6LMN5GDDQQSX3UHYXA",
  },
};

/**
 * Object containing error messages for various error codes.
 */
export const Errors = {
  1: { message: "Internal error" },
  2: { message: "Unauthorized error" },
  3: { message: "Insufficient balance" },
  4: { message: "Overflow error" },
};

/**
 * Class representing the TokenManager contract.
 */
export class TokenManagerContract extends Contract {
  static spec: ContractSpec = new ContractSpec([
    "AAAAAAAAAAAAAAAKaW5pdGlhbGl6ZQAAAAAABAAAAAAAAAAFYWRtaW4AAAAAAAATAAAAAAAAAAJkZXBvc2l0AAAAAAATAAAAAAAAAAl1c2VyAAAAEwAAAAAAAAAGYW1vdW50AAAAAAATAAAAAAAAAAR3aXRoZHJhdwAAAAAABgAAAAAAAAAFcmVzdWx0AAAAAAA=",
    "AAAAAAAAAAAAAAANZ2V0X2JhbGFuY2UAAAAAAAIAAAAAAAAAAl9yZXN1bHQAAAAAEwAAAAAAAAAJdXNlcl9hZGRyAAAAAAAT",
    "AAAAAAAAAAAAAAAAAUNvbnRyYWN0RXJyb3JNYW5hZ2VyAAAACwAAAAAAAAAAAAALAA==",
  ]);

  static readonly parsers = {
    initialize: (result: string) =>
      TokenManagerContract.spec.funcResToNative("initialize", result),
    deposit: (result: string) =>
      TokenManagerContract.spec.funcResToNative("deposit", result),
    withdraw: (result: string) =>
      TokenManagerContract.spec.funcResToNative("withdraw", result),
    get_balance: (result: string) =>
      TokenManagerContract.spec.funcResToNative("get_balance", result),
  };

  constructor(address: string) {
    super(address);
  }

  public initialize(admin: Address) {
    const invokeArgs = TokenManagerContract.spec.funcArgsToScVals(
      "initialize",
      {
        admin,
      },
    );
    const operation = this.call("initialize", ...invokeArgs);
    return operation.toXDR("base64");
  }

  public deposit(user: Address, amount: i128) {
    const invokeArgs = TokenManagerContract.spec.funcArgsToScVals("deposit", {
      user,
      amount,
    });
    const operation = this.call("deposit", ...invokeArgs);
    return operation.toXDR("base64");
  }

  public withdraw(user: Address, amount: i128) {
    const invokeArgs = TokenManagerContract.spec.funcArgsToScVals("withdraw", {
      user,
      amount,
    });
    const operation = this.call("withdraw", ...invokeArgs);
    return operation.toXDR("base64");
  }

  public get_balance(user: Address) {
    const invokeArgs = TokenManagerContract.spec.funcArgsToScVals(
      "get_balance",
      {
        user,
      },
    );
    const operation = this.call("get_balance", ...invokeArgs);
    return operation.toXDR("base64");
  }
}
```

### Helper Function: invokeSorobanOperation

```typescript
import {
  SorobanRpc,
  TransactionBuilder,
  TimeoutInfinite,
  xdr,
  Transaction,
} from "@stellar/stellar-sdk";

export async function invokeSorobanOperation<T>(
  operation: string,
  parser: (result: string) => T,
  txParams: TxParams,
  sorobanData?: xdr.SorobanTransactionData,
): Promise<T | undefined> {
  console.log("invoking soroban operation");
  const account = await config.rpc.getAccount(txParams.account.accountId());
  console.log("the account is", account);
  const txBuilder = new TransactionBuilder(account, txParams.txBuilderOptions)
    .addOperation(xdr.Operation.fromXDR(operation, "base64"))
    .setTimeout(TimeoutInfinite);

  if (sorobanData) {
    txBuilder.setSorobanData(sorobanData);
  }

  const transaction = txBuilder.build();
  console.log("Transaction built with sequence number:", transaction.sequence);

  const simulation = await config.rpc.simulateTransaction(transaction);

  if (SorobanRpc.Api.isSimulationError(simulation)) {
    console.log("Simulation error with details:", simulation);
    throw new Error(simulation.error);
  }

  const assembledTx = SorobanRpc.assembleTransaction(
    transaction,
    simulation,
  ).build();

  const signedTx = new Transaction(
    await txParams.signerFunction(assembledTx.toXDR()),
    config.passphrase,
  );

  try {
    const response = await sendTransaction(signedTx, parser);
    return response;
  } catch (error) {
    console.error("Transaction submission failed with error:", error);
    throw error;
  }
}
```

### Example TxParams

```typescript
const txParams: TxParams = {
  account: await config.rpc.getAccount(config.admin.publicKey()),
  txBuilderOptions: {
    fee: "10000",
    timebounds: {
      minTime: 0,
      maxTime: 0,
    },
    networkPassphrase: config.passphrase,
  },
  signerFunction: async (txXdr: string) => {
    return signWithKeypair(txXdr, config.passphrase, config.admin);
  },
};
```

### Example Invocation

```typescript
import { Address } from "@stellar/stellar-sdk";
import { TokenManagerContract } from "./TokenManagerContract";
import { invokeSorobanOperation, TxParams } from "./invokeSorobanOperation"; // Assuming you have these utility functions

// Create an instance of the contract client
const contractAddress =
  "CBEUVPRZKMCX5MPUAF2JMKMRIFEXXJXQXBLUUW6LMN5GDDQQSX3UHYXA";
const tokenManager = new TokenManagerContract(contractAddress);

// Define transaction parameters
const txParams: TxParams = {
  account: await config.rpc.getAccount(config.admin.publicKey()),
  txBuilderOptions: {
    fee: "10000",
    timebounds: {
      minTime: 0,
      maxTime: 0,
    },
    networkPassphrase: config.passphrase,
  },
  signerFunction: async (txXdr: string) => {
    return signWithKeypair(txXdr, config.passphrase, config.admin);
  },
};

// Invoke the initialize function
const adminAddress = Address.fromString(
  "GB4UG5H5MCYPIH7GM7CBZBLOOIE2K7HMDMPK4TPZ5UEIZ2HOI5RL535V",
);

const txXDR = tokenManager.initialize(adminAddress);
console.log("Transaction XDR:", txXDR);

// Example invocation
const result = await invokeSorobanOperation(
  txXDR,
  TokenManagerContract.parsers.initialize,
  txParams,
);
console.log("Result:", result);
```

### Conclusion

By following these steps, you can create a contract client and interact with Soroban smart contracts using JavaScript. This guide covered the basics of obtaining the contract specification, creating a contract client, and invoking contract functions.
