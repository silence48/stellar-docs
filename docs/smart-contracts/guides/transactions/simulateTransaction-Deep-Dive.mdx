## simulateTransaction Examples and Tutorials Guide

### Table of Contents

- [simulateTransaction Examples and Tutorials Guide](#simulatetransaction-examples-and-tutorials-guide)
  - [Table of Contents](#table-of-contents)
- [Overview](#overview)
- [When to Use `simulateTransaction` (whenever you use soroban :D )](#when-to-use-simulatetransaction-whenever-you-use-soroban-d-)
- [How to Call `simulateTransaction`](#how-to-call-simulatetransaction)
  - [Using Fetch](#using-fetch)
  - [Using the JavaScript SDK](#using-the-javascript-sdk)
- [Understanding the Footprint](#understanding-the-footprint)
- [Assembling a Transaction](#assembling-a-transaction)
  - [javascript-sdk-assembleTransaction](#javascript-sdk-assembletransaction)
- [Handling Archived Ledger Entries](#handling-archived-ledger-entries)
- [Fees and Resource Usage](#fees-and-resource-usage)
- [Preflight Error Handling](#preflight-error-handling)
  - [Common Preflight Errors](#common-preflight-errors)
- [Backend Code and Workflow](#backend-code-and-workflow)
- [Further Reading](#further-reading)

## Overview

The `simulateTransaction` endpoint in Soroban RPC allows you to submit a trial contract invocation to simulate how it would be executed by the Stellar network. This simulation calculates the effective transaction data, required authorizations, and minimal resource fee. It provides a way to test and analyze the potential outcomes of a transaction without actually submitting it to the network. It can be a nice way to get contract data as well sometimes.

While calling the method on the rpc server is not the ONLY way to simulate a transaction, it will likely be the most common and easiest way.

Here we will look at the objects involved and their definitions.

**SimulateTransactionParams** is the argument passed to the rpc endpoint for simulateTransaction

```typescript
interface SimulateTransactionParams {
  transaction: string; // The Stellar transaction to be simulated, serialized as a base64 string.
  resourceConfig?: {
    instructionLeeway: number; // Allow this many extra instructions when budgeting resources.
  };
}
```

**SimulateTransactionResult** is the return result from the call. It includes many useful things! let's take a look.

```typescript
interface SimulateTransactionResult {
  latestLedger: number; // The sequence number of the latest ledger known to Soroban RPC at the time it handled the request.
  minResourceFee?: string; // Recommended minimum resource fee to add when submitting the transaction. This fee is to be added on top of the Stellar network fee.
  cost?: {
    cpuInsns: string; // Total CPU instructions consumed by this transaction.
    memBytes: string; // Total memory bytes allocated by this transaction.
  };
  results?: {
    xdr: string; // Serialized base64 string - return value of the Host Function call.
    auth: string[]; // Array of serialized base64 strings - Per-address authorizations recorded when simulating this Host Function call.
  }[];
  transactionData?: string; // Serialized base64 string - The recommended Soroban Transaction Data to use when submitting the simulated transaction.
  events?: string[]; // Array of serialized base64 strings - The events emitted during the contract invocation.
  restorePreamble?: {
    // There is a restorePreamble if a ledgerkey or contract code is expired, and you can use the transactionData to build a new transaction.
    minResourceFee: string; // Recommended minimum resource fee to add when submitting the RestoreFootprint operation.
    transactionData: string; // The recommended Soroban Transaction Data to use when submitting the RestoreFootprint operation.
  };
  stateChanges?: {
    type: number; // Indicates if the entry was created (1), updated (2), or deleted (3).
    key: string; // The LedgerKey for this delta.
    before: string | null; // LedgerEntry state prior to simulation.
    after: string | null; // LedgerEntry state after simulation.
  }[];
  error?: string; // Details about why the invoke host function call failed.
}
```

## When to Use `simulateTransaction` (whenever you use soroban :D )

1. **Preparing `invokeHostFunctionOp` Transactions**: Anytime you need to submit an `invokeHostFunctionOp` transaction to the network.
2. **Footprint Determination**: To determine the ledger footprint, which includes all the data entries the transaction will read or write.
3. **Authorization Identification**: To identify the authorizations required for the transaction.
4. **Error Detection**: To detect potential errors and issues before actual submission, saving time and network resources.
5. **Restoring Archived Ledger Entries or Contract Code**: To prepare and restore archived data before actual transaction submission.
6. **Simulating Contract Getter Calls**: To retrieve certain data from the contract without affecting the ledger state.
7. **Resource Calculation**: To calculate the necessary resources (CPU instructions, memory, etc.) that a transaction will consume.

## How to Call `simulateTransaction`

### Using Fetch

Here's an example of how to call the `simulateTransaction` endpoint directly using `fetch` in JavaScript:

```javascript
async function simulateTransaction(transactionXDR) {
  const requestBody = {
    jsonrpc: "2.0",
    id: 8675309,
    method: "simulateTransaction",
    params: {
      transaction: transactionXDR,
      resourceConfig: {
        instructionLeeway: 50000,
      },
    },
  };

  const response = await fetch(
    "https://soroban-testnet.stellar.org/simulateTransaction",
    {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(requestBody),
    },
  );

  const result = await response.json();
  console.log(result);
}

// Example XDR transaction envelope
const transactionXDR =
  "AAAAAgAAAAAg4dbAxsGAGICfBG3iT2cKGYQ6hK4sJWzZ6or1C5v6GAAAAGQAJsOiAAAAEQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAGAAAAAAAAAABzAP+dP0PsNzYvFF1pv7a8RQXwH5eg3uZBbbWjE9PwAsAAAAJaW5jcmVtZW50AAAAAAAAAgAAABIAAAAAAAAAACDh1sDGwYAYgJ8EbeJPZwoZhDqEriwlbNnqivULm/oYAAAAAwAAAAMAAAAAAAAAAAAAAAA="; // Replace with your actual XDR transaction envelope
simulateTransaction(transactionXDR);
```

### Using the JavaScript SDK

The Stellar SDK provides a convenient method to simulate a transaction:

```javascript
const StellarSdk = require("stellar-sdk");

// Initialize the server
const server = new StellarSdk.Server("https://soroban-testnet.stellar.org");

// Define the transaction
const transaction = new StellarSdk.TransactionBuilder(account, {
  fee: StellarSdk.BASE_FEE,
})
  .setNetworkPassphrase(StellarSdk.Networks.TESTNET)
  .setTimeout(30)
  .addOperation(
    StellarSdk.Operation.invokeHostFunction({
      function: "increment",
    }),
  )
  .build();

server.simulateTransaction(transaction).then((sim) => {
  console.log("cost:", sim.cost);
  console.log("result:", sim.result);
  console.log("error:", sim.error);
  console.log("latestLedger:", sim.latestLedger);
});
```

## Understanding the Footprint

A footprint is a set of ledger keys that the transaction will read or write. These keys are marked as either read-only or read-write:

- **Read-Only Keys**: Available for reading only.
- **Read-Write Keys**: Available for reading and writing.

The footprint ensures that a transaction is aware of all the ledger entries it will interact with, preventing unexpected errors during execution.

## Assembling a Transaction

Once you have simulated the transaction and obtained the necessary data, you can assemble the transaction for actual submission. The `assembleTransaction` function in the SDK helps with this process, but you can also call `prepareTransaction` to have it both simulate and assemble the transaction for you.

### javascript-sdk-assembleTransaction

Here's how the `assembleTransaction` function in the javascript sdk works to combine the raw transaction with the simulation results:

```javascript
import {
  FeeBumpTransaction,
  Operation,
  Transaction,
  TransactionBuilder
} from '@stellar/stellar-base';

import { Api } from './api';
import { parseRawSimulation } from './parsers';

/**
 * Combines the given raw transaction alongside the simulation results.
 *
 * @param raw         the initial transaction, w/o simulation applied
 * @param simulation  the Soroban RPC simulation result (see
 *    {@link Server.simulateTransaction})
 *
 * @returns a new, cloned transaction with the proper auth and resource (fee,
 *    footprint) simulation data applied
 *
 * @note if the given transaction already has authorization entries in a host
 *    function invocation (see {@link Operation.invokeHostFunction}), **the
 *    simulation entries are ignored**.
 *
 * @see {Server.simulateTransaction}
 * @see {Server.prepareTransaction}
 */
export function assembleTransaction(
  raw: Transaction | FeeBumpTransaction,
  simulation:
    | Api.SimulateTransactionResponse
    | Api.RawSimulateTransactionResponse
): TransactionBuilder {
  if ('innerTransaction' in raw) {
    // TODO: Handle feebump transactions
    return assembleTransaction(
      raw.innerTransaction,
      simulation
    );
  }

  if (!isSorobanTransaction(raw)) {
    throw new TypeError(
      'unsupported transaction: must contain exactly one ' +
        'invokeHostFunction, extendFootprintTtl, or restoreFootprint ' +
        'operation'
    );
  }

  let success = parseRawSimulation(simulation);
  if (!Api.isSimulationSuccess(success)) {
    throw new Error

(`simulation incorrect: ${JSON.stringify(success)}`);
  }

  const classicFeeNum = parseInt(raw.fee) || 0;
  const minResourceFeeNum = parseInt(success.minResourceFee) || 0;
  const txnBuilder = TransactionBuilder.cloneFrom(raw, {
    // automatically update the tx fee that will be set on the resulting tx to
    // the sum of 'classic' fee provided from incoming tx.fee and minResourceFee
    // provided by simulation.
    //
    // 'classic' tx fees are measured as the product of tx.fee * 'number of
    // operations', In soroban contract tx, there can only be single operation
    // in the tx, so can make simplification of total classic fees for the
    // soroban transaction will be equal to incoming tx.fee + minResourceFee.
    fee: (classicFeeNum + minResourceFeeNum).toString(),
    // apply the pre-built Soroban Tx Data from simulation onto the Tx
    sorobanData: success.transactionData.build(),
    networkPassphrase: raw.networkPassphrase
  });

  switch (raw.operations[0].type) {
    case 'invokeHostFunction':
      // In this case, we don't want to clone the operation, so we drop it.
      txnBuilder.clearOperations();

      const invokeOp: Operation.InvokeHostFunction = raw.operations[0];
      const existingAuth = invokeOp.auth ?? [];
      txnBuilder.addOperation(
        Operation.invokeHostFunction({
          source: invokeOp.source,
          func: invokeOp.func,
          // if auth entries are already present, we consider this "advanced
          // usage" and disregard ALL auth entries from the simulation
          //
          // the intuition is "if auth exists, this tx has probably been
          // simulated before"
          auth: existingAuth.length > 0 ? existingAuth : success.result!.auth
        })
      );
      break;
  }

  return txnBuilder;
}

function isSorobanTransaction(tx: Transaction): boolean {
  if (tx.operations.length !== 1) {
    return false;
  }

  switch (tx.operations[0].type) {
    case 'invokeHostFunction':
    case 'extendFootprintTtl':
    case 'restoreFootprint':
      return true;

    default:
      return false;
  }
}
```

## Handling Archived Ledger Entries

When a ledger entry is archived, it needs to be restored before the transaction can be submitted. This is indicated in the `restorePreamble` field of the result.

```typescript
interface RestorePreamble {
  minResourceFee: string; // Recommended minimum resource fee to add when submitting the RestoreFootprint operation.
  transactionData: string; // The recommended Soroban Transaction Data to use when submitting the RestoreFootprint operation.
}
```

Here is an example for handling restoration using the `restorePreamble` to restore archived data:

```typescript
/**
 * Simulates a restoration transaction to determine if restoration is needed.
 * This function first checks the ledger entry for the given WASM hash. If the entry is found and has expired,
 * it attempts a restoration. If the entry hasn't expired yet but the TTL needs extension, it proceeds with TTL extension.
 * @param wasmHash - The hash of the WASM to check.
 * @param txParams - The transaction parameters including account and signer.
 * @returns A promise that resolves to a simulation response, indicating whether restoration or TTL extension is needed.
 */
export async function simulateRestorationIfNeeded(
  wasmHash: Buffer,
  txParams: TxParams,
): Promise<
  SorobanRpc.Api.SimulateTransactionRestoreResponse | string | undefined
> {
  try {
    const account = await config.rpc.getAccount(txParams.account.accountId());
    const ledgerKey = getLedgerKeyWasmId(wasmHash);
    const response = await config.rpc.getLedgerEntries(...[ledgerKey]);
    if (
      response.entries &&
      response.entries.length > 0 &&
      response.entries[0].liveUntilLedgerSeq
    ) {
      const expirationLedger = response.entries[0].liveUntilLedgerSeq;
      const desiredLedgerSeq = response.latestLedger + 500000;
      let extendLedgers = desiredLedgerSeq - expirationLedger;
      if (extendLedgers < 10000) {
        extendLedgers = 10000;
      }
      console.log("Expiration:", expirationLedger);
      console.log("Desired TTL:", desiredLedgerSeq);
      const sorobanData = new SorobanDataBuilder()
        .setReadWrite([ledgerKey])
        .build();
      const restoreTx = new TransactionBuilder(
        account,
        txParams.txBuilderOptions,
      )
        .setSorobanData(sorobanData)
        .addOperation(Operation.restoreFootprint({})) // The actual restore operation
        .build();
      // Simulate a transaction with a restoration operation to check if it's necessary

      const restorationSimulation: SorobanRpc.Api.SimulateTransactionResponse =
        await config.rpc.simulateTransaction(restoreTx);
      const restoreNeeded = SorobanRpc.Api.isSimulationRestore(
        restorationSimulation,
      );
      const resSimSuccess = SorobanRpc.Api.isSimulationSuccess(
        restorationSimulation,
      );
      console.log(
        `restoration needed: ${restoreNeeded}\nSimulation Success: ${resSimSuccess}`,
      );
      // Check if the simulation indicates a need for restoration
      if (restoreNeeded) {
        return restorationSimulation as SorobanRpc.Api.SimulateTransactionRestoreResponse;
      } else {
        console.log("No restoration needed., bumping the ttl.");
        const account1 = await config.rpc.getAccount(
          txParams.account.accountId(),
        );

        const bumpTTLtx = new TransactionBuilder(
          account1,
          txParams.txBuilderOptions,
        )
          .setSorobanData(
            new SorobanDataBuilder().setReadWrite([ledgerKey]).build(),
          )
          .addOperation(
            Operation.extendFootprintTtl({
              extendTo: desiredLedgerSeq,
            }),
          ) // The actual TTL extension operation
          .build();
        const ttlSimResponse: SorobanRpc.Api.SimulateTransactionResponse =
          await config.rpc.simulateTransaction(bumpTTLtx);
        const assembledTx = SorobanRpc.assembleTransaction(
          bumpTTLtx,
          ttlSimResponse,
        ).build();
        const signedTx = new Transaction(
          await txParams.signerFunction(assembledTx.toXDR()),
          config.passphrase,
        );
        // submit the assembled and signed transaction to bump it.
        try {
          const response = await sendTransaction(signedTx, (result) => {
            console.log(`bump ttl for contract result: ${result}`);
            return result;
          });
          return response;
        } catch (error) {
          console.error("Transaction submission failed with error:", error);
          throw error;
        }
      }
    } else {
      console.log("No ledger entry found for the given WASM hash.");
    }
  } catch (error) {
    console.error("Failed to simulate restoration:", error);
    throw error;
  }
  return undefined;
}

/**
 * Handles the restoration of a Soroban contract.
 * @param {SorobanRpc.Api.SimulateTransactionRestoreResponse} simResponse - The simulation response containing restoration information.
 * @param {TxParams} txParams - The transaction parameters.
 * @returns {Promise<void>} A promise that resolves when the restoration transaction has been submitted.
 */
export async function handleRestoration(
  simResponse: SorobanRpc.Api.SimulateTransactionRestoreResponse,
  txParams: TxParams,
): Promise<void> {
  const restorePreamble = simResponse.restorePreamble;
  console.log("Restoring for account:", txParams.account.accountId());
  const account = await config.rpc.getAccount(txParams.account.accountId());
  // Construct the transaction builder with the necessary parameters
  const restoreTx = new TransactionBuilder(account, {
    ...txParams.txBuilderOptions,
    fee: restorePreamble.minResourceFee, // Update fee based on the restoration requirement
  })
    .setSorobanData(restorePreamble.transactionData.build()) // Set Soroban Data from the simulation
    .addOperation(Operation.restoreFootprint({})) // Add the RestoreFootprint operation
    .build(); // Build the transaction

  const simulation: SorobanRpc.Api.SimulateTransactionResponse =
    await config.rpc.simulateTransaction(restoreTx);
  const assembledTx = SorobanRpc.assembleTransaction(
    restoreTx,
    simulation,
  ).build();

  const signedTx = new Transaction(
    await txParams.signerFunction(assembledTx.toXDR()),
    config.passphrase,
  );

  console.log("Submitting restoration transaction");

  try {
    // Submit the transaction to the network
    const response = await config.rpc.sendTransaction(signedTx);
    console.log(
      "Restoration transaction submitted successfully:",
      response.hash,
    );
  } catch (error) {
    console.error("Failed to submit restoration transaction:", error);
    throw new Error("Restoration transaction failed");
  }
}

import {
  Account,
  Keypair,
  Operation,
  SorobanDataBuilder,
  SorobanRpc,
  TimeoutInfinite,
  Transaction,
  TransactionBuilder,
  scValToNative,
  xdr,
} from "@stellar/stellar-sdk";
```

## Fees and Resource Usage

Soroban smart contracts on Stellar use a multidimensional resource fee model, charging fees for several resource types:

1. **CPU Instructions**: Number of CPU instructions the transaction uses.
2. **Ledger Entry Accesses**: Reading or writing any single ledger entry.
3. **Ledger I/O**: Number of bytes read from or written to the ledger.
4. **Transaction Size**: Size of the transaction submitted to the network in bytes.
5. **Events & Return Value Size**: Size of the events produced by the contract and the return value of the top-level contract function.
6. **Ledger Space Rent**: Payment for ledger entry TTL extensions and rent payments for increasing ledger entry size.

Fees are calculated based on the resource consumption declared in the

transaction. Refundable fees are charged before execution and refunded based on actual usage, while non-refundable fees are calculated from CPU instructions, read bytes, write bytes, and transaction size.

## Preflight Error Handling

The preflight mechanism provides an estimation of CPU and memory consumption in a transaction. It helps identify potential errors and resource limitations before actual submission. Errors returned by the host are propagated through RPC and do not cover network errors or errors in RPC itself.

### Common Preflight Errors

- **HostError(Budget, LimitExceeded)**: Network-defined resource limit exceeded. Optimize the contract to consume fewer resources.
- **HostError(Storage, MissingValue)**: Trying to access a non-existent ledger entry. Deploy the respective contract or Wasm.
- **HostError(WasmVm, InvalidAction)**: Failure in a Wasm contract, typically a panic. Fix the contract logic or invocation arguments.

## Backend Code and Workflow

The `simulateTransaction` endpoint leverages various backend components to simulate the execution of a transaction. Here is a brief explanation of how it works:

1. **Invocation of Simulation**:

   - The simulation is initiated by calling `simulate_invoke_host_function_op` which takes in parameters such as the transaction to be simulated, resource configuration, and other necessary details.

2. **Snapshot Source and Network Configuration**:

   - The simulation utilizes a snapshot source (`MockSnapshotSource`) and network configuration (`NetworkConfig`) to mimic the state of the ledger and network conditions.

3. **Resource Calculation**:

   - The function `simulate_invoke_host_function_op_resources` computes the resources (CPU instructions, memory bytes) required for the transaction by analyzing ledger changes.

4. **Execution and Result Handling**:

   - The core of the execution is handled by `invoke_host_function_in_recording_mode`, which records the transaction's impact on the ledger.
   - The results are then processed, including any required authorizations, emitted events, and transaction data.

5. **Adjustments and Fees**:
   - Adjustments to resource usage and fees are made based on predefined configurations (`SimulationAdjustmentConfig`), ensuring accurate fee estimation.

These functions are defined in the [`rs-soroban-env`](https://github.com/stellar/rs-soroban-env) and also in a [`soroban-simulation`](https://github.com/stellar/rs-soroban-env/tree/main/soroban-simulation) [crate](https://crates.io/crates/soroban-simulation) and handle the core logic for simulating transactions.

## Further Reading

For more information and examples, check out the code and other documentation:

- [openRpc Documentation](https://developers.stellar.org/network/soroban-rpc/api-reference/methods/simulateTransaction)
- [openRpc json Specification](https://github.com/stellar/stellar-docs/blob/main/static/openrpc.json)
- [preflight.go](https://github.com/stellar/soroban-rpc/blob/release/v21.0.0/cmd/soroban-rpc/internal/preflight/preflight.go)
- [Soroban Example Code](https://github.com/stellar/soroban-examples)
- [Stellar SDK Documentation](https://stellar.github.io/js-stellar-sdk/)
